{"version":3,"sources":["index.ts","comsumer/index.ts","comsumer/parse.ts","something-wrong.ts"],"names":["console","log","JSON","stringify","jsonFile","somethingWrong","e","emit","parse","err","map","stacks","parseError","occured","loc","slice","sliced","split","column","pop","trace","filename","line","Number","existsSync","Error","sourcemapRaw","readFileSync","sourcemap","SourceMapConsumer","result","originalPositionFor","target","source","errorFile","errorLine","unshift","at","originalFile","parsed","message","st","stack","$","exec","replace"],"mappings":";;;;;;;;;;;;;0HAKA,AAGA,AAEA,EAFE,EAHE,AACFA,AAGAO,IAAAA,CADOD,GAFCL,AAEE,EACN,CAHO,CAAC,AAGPK,CAHQ,CANM,CASX,SAHgB,EAAEJ,KAAKC,SAAS,CALX,AAKYC,SAAQ,EAAE,CAAC,CAAC,GACrDC,IAAAA,gBAAc,GAJK;uICsCrB,AAMA,AAESG,AAAOD,IAzCd,AAWA,AAEA,AAIA,AAaA,AAEA,AAA0D,AAI1D,AACAP,AAIkB,CA1CLQ,AAoCAD,AAMD,EA1CCC,AAAMC,AAoCNF,AAAKD,CApCLE,AAAgB,AACvBG,AAQJU,AACAC,AACAJ,AAGE,AAIEQ,AAWJW,AACAvB,AAGK,AAAEQ,AAAiBgB,AAAyB3B,AAGtCJ,AAAa,AACpBgC,CAvBDf,CAd0Bd,AAoCHA,CApCe,AA4B3C,AAACC,AAQsC,AAMhCH,AAAOD,CA1ChB,AACiBK,AAiBMV,AAWf,AAOR,AACiB,AACPD,CAxBHuB,AAcWY,AAET,CApCgC,AAMzC,AAUUb,AAuBOY,AAGjB,CAEa,CArCIvB,AAULW,AAmBAS,AAGyCrB,AAKvCL,CApBcE,CATdK,AAqBK,AAOIL,AACPgC,CARI,CAFK,AASIlC,CA/BdU,AAsBW,AAEJc,CAZW,AAeSI,CA3BpBf,AAKHD,AAOeS,AAYLL,AAOGZ,CArCXD,AAoCDH,CApCW,AAcd,AAsBW,AAEL,CAhCE,CANQI,AAcfA,AAIgBiB,AAYD,AAMHjB,CApCe,AAClB,AA6BO,AAMO,AAGvCV,CATiC,CA7BPS,CAcxB,AAeiCqB,EAlCH,AAkCUZ,CA5BpCL,EAqCEZ,CAxBA,AAAIwB,CAbI,AAACd,CAAc,AA4BiB,AASrC,CArCqB,AAqCpB,CArBgC,AAYM,AASrC,CArCqB,CAACG,AAajB,AAG2BJ,AAqB9B,EAAE6B,CArCqB,AAgBsB,CAhBrBxB,AAqCfO,IAAI,CArCgB,AAqCf,CArCgB,GAAG,CAkB1CM,AAmB4B,EAAE,AAACW,CAzCZ,CAKnBvB,AAiBY,AAmB0BL,IApC7BE,AAiBOgB,EAjBCZ,AAoC2B,AAAQ,CAAC,EAAE,CAACH,CApClC,CAAC,CAoCoC,CAAC,CAAC,CAAC,EAlC9DI,IAASF,CAewB,CAfjBG,AAekBO,GAff,CAiBnBI,GAdAV,CAcS,AAAC,CAAA,EAdF,IAcQQ,CAAQ,EAAGG,mBAAmB,CAACX,IAC/CY,IAASF,EAAOG,MAAM,EAEtBC,IAAYP,IAAAA,cAAY,EAACK,GAAQ,SAASf,KAAK,CAAC,OAChDkB,IAAYD,CAAS,CAACJ,EAAOR,IAAI,GAAG,EAAE;mICjC9C,AAcA,IAbE,AACA,AAWA,IAZMmB,AAAKhC,AAETiC,AACA,AAGA,AAKA,CAZK9B,EAAWH,CAAU,AAGlBiC,AACFC,AACJN,AACAvB,EAHYC,CAMd4B,AAOK/B,CAZK,AACJ,CACC,AAGLE,EAPG2B,AACc,CAAC,AAMf,EARIhC,CAQD,AAAC,CAAA,EARAA,EAAIiC,IACRD,CADa,CACT/B,CAcJE,CAPgBgC,CAPT,CAAC,CAACF,CAOW,CAACA,MAAU,EAR3BjC,AAQ4B,AAAC,CAAC,CAAC,EAAE,IAAI,IAC9CkC,CATSlC,CASP4B,CATkBpB,CAShB,GAAGyB,CATkB,CAAC,AASbG,MATmB9B,CASZ,CAAC4B,EAAE7B,CATc,CAAC,CASZ,EAAE,KAErB6B;oICZJ,AAEP,IADE,KADctC,CACR,AAAIoB,KADIpB,CACE,mBADFA","file":"bundle.js","sourceRoot":"D:\\serpack\\fixtures\\sourcemap","sourcesContent":["import { emit } from './comsumer';\r\nimport { somethingWrong } from './something-wrong';\r\n\r\nimport jsonFile from '../../package.json';\r\n\r\ntry {\r\n  console.log(`JSON Data: ${JSON.stringify(jsonFile)}!`);\r\n  somethingWrong();\r\n} catch (e) {\r\n  emit(e, './fixtures/sourcemap/compiled.js.map');\r\n}\r\n","// src/parse.ts\r\nimport { existsSync, readFileSync } from 'fs';\r\nimport { join, dirname } from 'path';\r\nimport { SourceMapConsumer } from 'source-map';\r\n\r\nimport { parseError } from './parse';\r\n\r\nasync function parse(err: Error, map?: string) {\r\n  const stacks = parseError(err);\r\n  const occured = (stacks as any)[0].loc.slice(1, -1);\r\n  const sliced = occured.split(':');\r\n\r\n  const column = sliced.pop();\r\n  const line = sliced.pop();\r\n\r\n  const trace = {\r\n    filename: occured,\r\n    line: Number(line),\r\n    column: Number(column),\r\n  };\r\n\r\n  if (!existsSync(map as string)) {\r\n    throw new Error(\".map file desn't exist\");\r\n  }\r\n\r\n  const sourcemapRaw = JSON.parse(readFileSync(map as string, 'utf-8'));\r\n\r\n  const sourcemap = new SourceMapConsumer(sourcemapRaw);\r\n\r\n  const result = (await sourcemap).originalPositionFor(trace);\r\n  const target = result.source;\r\n\r\n  const errorFile = readFileSync(target, 'utf-8').split('\\n');\r\n  const errorLine = errorFile[result.line - 1];\r\n\r\n  (stacks as any).unshift({\r\n    at: '',\r\n    loc: `${target}:${result.line}:${result.column}`,\r\n  });\r\n\r\n  return { line: errorLine, originalFile: errorFile, stacks };\r\n}\r\n\r\nasync function emit(e: Error, map: string) {\r\n  const parsed = await parse(e, map);\r\n  console.log(e.message);\r\n  console.log(`> ${parsed.line} (at ${(parsed.stacks as any)[0].loc})`);\r\n}\r\n\r\nexport { parse, emit };\r\n","function parseError(err: Error) {\r\n  const st = err.stack?.split('\\n').slice(1);\r\n  return st?.map((stack) => {\r\n    stack = stack.slice(7);\r\n    const $ = {\r\n      at: '',\r\n      loc: '',\r\n    };\r\n\r\n    $.loc = (/\\([^)]*\\)/.exec(stack) || [])[0] || '';\r\n    $.at = stack.replace($.loc, '');\r\n\r\n    return $;\r\n  });\r\n}\r\n\r\nexport { parseError };\r\n","export function somethingWrong() {\r\n  throw new Error('Something is wrong!');\r\n}\r\n"]}