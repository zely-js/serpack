{"version":3,"sources":["index.ts","comsumer/index.ts","comsumer/parse.ts","something-wrong.ts"],"names":["somethingWrong","e","emit","join","parse","err","map","stacks","parseError","occured","loc","slice","sliced","split","column","pop","trace","filename","line","Number","existsSync","Error","sourcemapRaw","JSON","readFileSync","sourcemap","SourceMapConsumer","result","originalPositionFor","target","source","errorFile","errorLine","unshift","at","originalFile","parsed","console","log","message","st","stack","$","exec","replace"],"mappings":";;;;;;;;;;;;;0HAIA,AAEA,AAEA,EAFE,EAFE,AACFA,AAEAE,IAFAF,AAEAE,CADOD,GAAG,EACN,EAACA,EAPc,CAOXE,IAAAA,CAFM,KAEF,EAAC,QANM,2BACU;uICuC/B,AAMA,AAESC,AAAOF,IAzCd,AAWA,AAEA,AAIA,AAaA,AAEA,AAA0D,AAI1D,AACAmC,AAIkB,CA1CLjC,AAoCAF,AAMD,EA1CCE,AAAMC,AAoCNH,AAAKD,CApCLG,AAAgB,AACvBG,AAQJU,AACAC,AACAJ,AAGE,AAIEQ,AAWJY,AACAxB,AAGK,AAAEQ,AAAiBiB,AAAyB5B,AAGtCL,AAAa,AACpBkC,CAvBDhB,CAd0Bd,AAoCHA,CApCe,AA4B3C,AAACC,AAQsC,AAMhCH,AAAOF,CA1ChB,AACiBM,AAiBMe,AAWf,AAOR,AACiB,AACPe,CAxBHlB,AAcWa,AAET,CApCgC,AAMzC,AAUUd,AAuBOa,AAGjB,CAEa,CArCIxB,AAULW,AAmBAU,AAGyCtB,AAKvCN,CApBcG,CATdK,AAqBK,AAOIL,AACPmC,CARI,CAFK,AASItC,CA/BdW,AAsBW,AAEJe,CAZW,AAeSI,CA3BpBhB,AAKHD,AAOeU,AAYLN,AAOGZ,CArCXD,AAoCDJ,CApCW,AAcd,AAsBW,AAEL,CAhCE,CANQK,AAcfA,AAIgBkB,AAYD,AAMHlB,CApCe,AAClB,AA6BO,AAMO,AAGvC+B,CATiC,CA7BPhC,CAcxB,AAeiCsB,EAlCH,AAkCUb,CA5BpCL,EAqCE6B,CAxBA,AAAIjB,CAbI,AAACd,CAAc,AA4BiB,AASrC,CArCqB,AAqCpB,CArBgC,AAYM,AASrC,CArCqB,CAACG,AAajB,AAG2BJ,AAqB9B,EAAE8B,CArCqB,AAgBsB,CAhBrBzB,AAqCfO,IAAI,CArCgB,AAqCf,CArCgB,GAAG,CAkB1CO,AAmB4B,EAAE,AAACW,CAzCZ,CAKnBxB,AAiBY,AAmB0BL,IApC7BE,AAiBOiB,EAjBCb,AAoC2B,AAAQ,CAAC,EAAE,CAACH,CApClC,CAAC,CAoCoC,CAAC,CAAC,CAAC,EAlC9DI,IAASF,CAewB,CAfjBG,AAekBO,GAff,CAiBnBK,GAdAX,CAcS,AAAC,CAAA,EAdF,IAcQS,CAAQ,EAAGG,mBAAmB,CAACZ,IAC/Ca,IAASF,EAAOG,MAAM,EAEtBC,IAAYP,IAAAA,cAAY,EAACK,GAAQ,SAAShB,KAAK,CAAC,OAChDmB,IAAYD,CAAS,CAACJ,EAAOT,IAAI,GAAG,EAAE;mICjC9C,AAcA,IAbE,AACA,AAWA,IAZMsB,AAAKnC,AAEToC,AACA,AAGA,AAKA,CAZKjC,EAAWH,CAAU,AAGlBoC,AACFC,AACJR,AACAxB,EAHYC,CAMd+B,AAOKlC,CAZK,AACJ,CACC,AAGLE,EAPG8B,AACc,CAAC,AAMf,EARInC,CAQD,AAAC,CAAA,EARAA,EAAIoC,IACRD,CADa,CACTlC,CAcJE,CAPgBmC,CAPT,CAAC,CAACF,CAOW,CAACA,MAAU,EAR3BpC,AAQ4B,AAAC,CAAC,CAAC,EAAE,IAAI,IAC9CqC,CATSrC,CASP6B,CATkBrB,CAShB,GAAG4B,CATkB,CAAC,AASbG,MATmBjC,CASZ,CAAC+B,EAAEhC,CATc,CAAC,CASZ,EAAE,KAErBgC;oICZJ,AAEP,IADE,KADc1C,CACR,AAAIqB,KADIrB,CACE,mBADFA","file":"bundle.js","sourceRoot":"D:\\serpack\\fixtures\\sourcemap","sourcesContent":["import { join } from 'path';\r\nimport { emit } from './comsumer';\r\nimport { somethingWrong } from './something-wrong';\r\n\r\ntry {\r\n  somethingWrong();\r\n} catch (e) {\r\n  emit(e, join('./fixtures/sourcemap/compiled.js.map'));\r\n}\r\n","// src/parse.ts\r\nimport { existsSync, readFileSync } from 'fs';\r\nimport { join, dirname } from 'path';\r\nimport { SourceMapConsumer } from 'source-map';\r\n\r\nimport { parseError } from './parse';\r\n\r\nasync function parse(err: Error, map?: string) {\r\n  const stacks = parseError(err);\r\n  const occured = (stacks as any)[0].loc.slice(1, -1);\r\n  const sliced = occured.split(':');\r\n\r\n  const column = sliced.pop();\r\n  const line = sliced.pop();\r\n\r\n  const trace = {\r\n    filename: occured,\r\n    line: Number(line),\r\n    column: Number(column),\r\n  };\r\n\r\n  if (!existsSync(map as string)) {\r\n    throw new Error(\".map file desn't exist\");\r\n  }\r\n\r\n  const sourcemapRaw = JSON.parse(readFileSync(map as string, 'utf-8'));\r\n\r\n  const sourcemap = new SourceMapConsumer(sourcemapRaw);\r\n\r\n  const result = (await sourcemap).originalPositionFor(trace);\r\n  const target = result.source;\r\n\r\n  const errorFile = readFileSync(target, 'utf-8').split('\\n');\r\n  const errorLine = errorFile[result.line - 1];\r\n\r\n  (stacks as any).unshift({\r\n    at: '',\r\n    loc: `${target}:${result.line}:${result.column}`,\r\n  });\r\n\r\n  return { line: errorLine, originalFile: errorFile, stacks };\r\n}\r\n\r\nasync function emit(e: Error, map: string) {\r\n  const parsed = await parse(e, map);\r\n  console.log(e.message);\r\n  console.log(`> ${parsed.line} (at ${(parsed.stacks as any)[0].loc})`);\r\n}\r\n\r\nexport { parse, emit };\r\n","function parseError(err: Error) {\r\n  const st = err.stack?.split('\\n').slice(1);\r\n  return st?.map((stack) => {\r\n    stack = stack.slice(7);\r\n    const $ = {\r\n      at: '',\r\n      loc: '',\r\n    };\r\n\r\n    $.loc = (/\\([^)]*\\)/.exec(stack) || [])[0] || '';\r\n    $.at = stack.replace($.loc, '');\r\n\r\n    return $;\r\n  });\r\n}\r\n\r\nexport { parseError };\r\n","export function somethingWrong() {\r\n  throw new Error('Something is wrong!');\r\n}\r\n"]}